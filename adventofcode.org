

* Advent of Code 2022

** Day 1
#+begin_src python :exports both
inp = open("/home/uni/Sync/aoc/input1").readlines()
splits = []
s = []
for i in inp:
  if i == "\n":
    splits.append(s.copy())
    s = []
  else:
    s.append(int(i.strip()))
splits = map(sum, splits)
return sum(sorted(splits)[-3:])
#+END_src

#+RESULTS:
: 198041

** Day 2
#+begin_src haskell :compile yes :results output :exports both
import Data.Char
main =  print . func . (map (\[[x],[y]] -> (x,y))) . map words . lines =<< readFile "/home/uni/Sync/aoc/input2"
func :: [(Char, Char)] -> Int
func = sum . map (\(a,b) -> charScore a b + winScore a b)
  where charScore a b =
          (ord b - ord 'X' + 1)
        winScore a b | (ord a - ord 'A') == (ord b - ord 'X') = 3
                     | otherwise = case (a,b) of
                         ('A','Y') -> 6
                         ('B','Z') -> 6
                         ('C','X') -> 6
                         _         -> 0
#+end_src

#+RESULTS:
: 11666

#+begin_src haskell :compile yes :results output :exports both
import Data.Char
main =  print . func . (map (\[[x],[y]] -> (x,y))) . map words . lines =<< readFile "/home/uni/Sync/aoc/input2"
func :: [(Char, Char)] -> Int
func = sum . map (\(a,b) -> charScore a b + winScore a b) . map (\(x,y) -> (x,choosePlay x y))
  where charScore a b =
          (ord b - ord 'X' + 1)
        winScore a b | (ord a - ord 'A') == (ord b - ord 'X') = 3
                     | otherwise = case (a,b) of
                         ('A','Y') -> 6
                         ('B','Z') -> 6
                         ('C','X') -> 6
                         _         -> 0
        choosePlay a 'Y' = chr ((ord a - ord 'A') + ord 'X')
        choosePlay 'A' 'X' = 'Z'
        choosePlay 'B' 'X' = 'X'
        choosePlay 'C' 'X' = 'Y'
        choosePlay 'A' 'Z' = 'Y'
        choosePlay 'B' 'Z' = 'Z'
        choosePlay 'C' 'Z' = 'X'
#+end_src

#+RESULTS:
: 12767

** Day 3
#+begin_src ruby :results output :exports both
class String
  def halves
    chars.each_slice(size / 2).map(&:join)
  end
    end
n = 0
File.foreach("input3") do |x|
  dep1, dep2 = x.halves
  char = (dep1.split('') & dep2.split('')).first
  n += (char.bytes.map {|x| x - 64}.first)+26  if char == char.upcase
  n += (char.bytes.map {|x| x - 96}.first)  if char == char.downcase
end
puts n
     n = 0
File.foreach("input3").each_slice(3) do |xs|
  char = (xs[0].split('') & xs[1].split('') & xs[2].split('')).first
  n += (char.bytes.map {|x| x - 64}.first)+26  if char == char.upcase
  n += (char.bytes.map {|x| x - 96}.first)  if char == char.downcase
end
puts n
#+end_src

#+RESULTS:
: 7848
: 2616

** Day 4
#+begin_src bash :exports both
i=0;
while read p; do
p=(${p//[,-]/ })
if (( (p[0] <= p[2] && p[1] >= p[3]) || (p[0] >= p[2] && p[1] <= p[3]) ))
then
$((i+=1))
fi
done < input4
echo $i
#+end_src

#+RESULTS:
: 500

#+begin_src bash :exports both
i=0;
while read p; do
p=(${p//[,-]/ })
if (( (p[0] <= p[2] && p[1] >= p[2]) || (p[0] >= p[2] && p[0] <= p[3]) ))
then
$((i+=1))
fi
done < input4
echo $i
#+end_src

#+RESULTS:
: 815

** Day 5
#+begin_src racket :results output :exports both
#lang racket

(define (string-group input n)
   (map (lambda (x) (substring input x (min (+ x n) (string-length input)))) (range 0 (string-length input) n)))
(define (parse input)
  (let* ((split1 (string-split input "\n\n"))
         (header* (first split1))
         (header**
          (apply map list
                 (map (lambda (a)
                       (string-group a 4)) (string-split  header* "\n"))))
         (header (map (lambda (a) (filter non-empty-string? (map (lambda (b) (string-trim (string-replace b #rx"\\[|\\]*" ""))) (drop-right a 1)))) header**))
         (footer* (map (lambda (a) (list (string->number (second (string-split a))) (string->number (fourth (string-split a))) (string->number (sixth (string-split a))))) (string-split (second split1) "\n")))) (list header footer*)))



(define (act-single value many from to)
  (list-update (list-update value (- to 1)
                            (lambda (u)
                              (append
                               (reverse
                                (take (list-ref value (- from 1)) many))
                               u)))
    (- from 1)
    (lambda (u) (drop u many))))


(define (act-single* value many from to)
  (list-update (list-update value (- to 1)
                            (lambda (u)
                              (append
                                (take (list-ref value (- from 1)) many)
                               u)))
    (- from 1)
    (lambda (u) (drop u many))))



(define (act header footer) (foldl (lambda (a b) (act-single b (first a) (second a) (third a))) header footer))
(define (act* header footer) (foldl (lambda (a b) (act-single* b (first a) (second a) (third a))) header footer))
(define part1 (apply string-append (map first (apply act (parse (file->string "input5"))))))
(define part2 (apply string-append (map first (apply act* (parse (file->string "input5"))))))
part1
part2

#+end_src

#+RESULTS:
: "WHTLRMZRC"
: "GMPMLWNMG"


** Day 6
#+begin_src C :includes <stdio.h> :exports both
    FILE* file = fopen("input6","r");
    int i = 0;
    char* chars = malloc(4);
    for(;;){
      fseek(file, i, SEEK_SET);
      chars[0] = fgetc(file);
      chars[1] = fgetc(file);
      chars[2] = fgetc(file);
      chars[3] = fgetc(file);
      if(chars[0] != chars[1] && chars[0] != chars[2] && chars[0] != chars[3] && chars[1] != chars[2] && chars[1] != chars[3] && chars[2] != chars[3]) {
        printf("%d", i + 4);
        return 0;
      }
      if(chars[0] == 0) return 0;
      i++;

    }

#+end_src

#+RESULTS:
: 1658


#+begin_src C :includes <stdio.h> :exports both
    FILE* file = fopen("input6","r");
    int i = 0;
    char* chars = malloc(14);
    for(;;){
      fseek(file, i, SEEK_SET);
      int alldifferent = 1;
      for(int j = 0; j < 14; j++) {
        chars[j] = fgetc(file);
        for(int k = 0; k < j; k++) {
          if(chars[k] == chars[j]) alldifferent = 0;
        }
      }
      if(alldifferent){
        printf("%d", i + 14);
        return 0;
      }
      if(chars[0] == 0) return 0;
      i++;

    }

#+end_src

#+RESULTS:
: 2260

** Day 7

#+begin_src js :results output :exports both
const fs = require('fs');
const input = fs.readFileSync('input7', 'utf8').split("\n").slice(1).map(element => { return element.trim().split(" "); });

function accessJSON(d,p) {
    d2 = d;
    for(i of p) {
        d2 = d2[p];
    }
    return d2;
}

path = [];
data = {'/': 0};
lsMode = false;
for(const line of  input) {
    if(line[0] == "$") {
        if(line[1] == "ls") {

        }
        else if(line[1] == "cd") {

            if(line[2] == "..") { path = path.slice(0,path.length-1);  }
            else {
                //console.log(("data".concat("[\"",path.join("\"][\""), "\"\]", "= {};")));
                data["/"+path.join("/")] = isNaN(data["/"+path.join("/")]) ? 0 : data["/"+path.join("/")];
                path.push(line[2]);
                data["/"+path.join("/")] = isNaN(data["/"+path.join("/")]) ? 0 : data["/"+path.join("/")];
            }
        }
    }
    else if("dir" != line[0]) {
        size = +line[0];
        file = line[1];
        //console.log(path, data["/"+path.slice(0,i).join("/")], +line[0]);
        for(var i = 0; i <= path.length; i++) {
            //console.log("/"+path.slice(0,i).join("/"));
            data["/"+path.slice(0,i).join("/")] += size;
        }
    }
}


console.log(Object.values(data).filter(element => {return element < 100000; }).reduce((a,b) => a + b,0));
free = 70000000 - data["/"];
needed = 30000000 - free;

var filtered = Object.keys(data ).reduce(function (filtered, key) {
    if (data[key] >= needed) filtered[key] = data[key];
    return filtered;
}, {});

var [lowestItems] = Object.entries(filtered).sort(([ ,v1], [ ,v2]) => v1 - v2);
console.log(lowestItems);
#+end_src

#+RESULTS:
: 1444896
: [ '/jvwtm/zjmldjdh/mdclfbs', 404395 ]

** Day 8
#+begin_src octave :exports both
siz = 99;
file = fopen("input8");
a = zeros(siz);
seen = zeros(siz);
for i = 1:siz;
  for j=1:siz;
    a(i,j) = str2double(fgets(file,1));
  end
  fgets(file,1);
end
for i = 1:siz;
  oldLeft = -1;
  for j=1:siz;
    if(a(i,j) < oldLeft);
      %break
    else
      if(a(i,j) > oldLeft);
        seen(i,j) = 1;
      end
      oldLeft = a(i,j);
    end
  end
end
for i = 1:siz;
  oldRight = -1;
  for j=1:siz;
    if(a(i,siz+1-j) < oldRight);
      %break
    else
      if(a(i,siz+1-j) > oldRight);
        seen(i,siz+1-j) = 1;
      end
      oldRight = a(i,siz+1-j);
    end
  end
end
for j = 1:siz;
  oldTop = -1;
  for i=1:siz;
    if(a(i,j) < oldTop);
      %break
    else
      if(a(i,j) > oldTop);
        seen(i,j) = 1;
      end
      oldTop = a(i,j);
    end
  end
end
for j = 1:siz;
  oldBottom = -1;
  for i=1:siz;
    if(a(siz+1-i,j) < oldBottom);
      %break
    else
      if(a(siz+1-i,j) > oldBottom);
        seen(siz+1-i,j) = 1;
      end
      oldBottom = a(siz+1-i,j);
    end
  end
end
sum(seen(:))
#+end_src

#+RESULTS:
: 1719

#+begin_src octave :exports both
siz = 99;
file = fopen("input8");
a = zeros(siz);
score = zeros(siz);
for i = 1:siz;
  for j=1:siz;
    a(i,j) = str2double(fgets(file,1));
  end
  fgets(file,1);
end
for i=1:siz;
  for j=1:siz;
    down=0;
    for d=i+1:siz;
      down = down + 1;
      if(a(d,j) >= a(i,j));
        break
      end
    end
    up=0;
    for d=i-1:-1:1;
      up = up + 1;
      if(a(d,j) >= a(i,j));
        break
      end
    end
    right=0;
    for d=j+1:siz;
      right = right + 1;
      if(a(i,d) >= a(i,j));
        break
      end
    end
    left=0;
    for d=j-1:-1:1;
      left = left + 1;
      if(a(i,d) >= a(i,j));
        break
      end
    end
    score(i,j) = down * up * left * right;
  end
end
max(score(:))
#+end_src

#+RESULTS:
: 590824

** Day 9
https://stackoverflow.com/questions/2291802/is-there-a-c-iterator-that-can-iterate-over-a-file-line-by-line
https://stackoverflow.com/questions/1903954/is-there-a-standard-sign-function-signum-sgn-in-c-c

#+begin_src cpp :results output :main no :includes <iostream> <fstream> <string> <vector> <unordered_set> :options -Wall

const std::pair<int,int> get_direction(const char dir) {
   if (dir == 'U') return std::pair(0,1);
   else if (dir == 'D') return std::pair(0,-1);
   else if (dir == 'L') return std::pair(-1,0);
   else if (dir == 'R') return std::pair(1,0);
}


const bool are_nearby(const std::vector<int> head, const std::vector<int> tail) {
    return abs(head[0] - tail[0]) <= 1 && abs(head[1] - tail[1]) <= 1;
}

template <typename T> int sgn(T val) {
    return (T(0) < val) - (val < T(0));
}

auto stringify = [](const std::vector<int>& p, std::string sep = "-")-> std::string{
        return std::to_string(p[0]) + sep + std::to_string(p[1]);
    };
const std::vector<int> update_tail(std::vector<int> tail_pos, std::vector<int> head_pos, const int dx, const int dy, std::unordered_set<std::string>& vis) {
    for (int i=0; i<abs(dx); i++){
        head_pos[0]+=sgn(dx);
        if(!are_nearby(head_pos, tail_pos)) {
            tail_pos[0]+=sgn(dx);
            tail_pos[1] += sgn(head_pos[1]-tail_pos[1]);

        }
        vis.insert(stringify(tail_pos));
        //std::cout << "HEAD: " << head_pos[0] << "," << head_pos[1] << "\n";
        //std::cout << "TAIL: " << tail_pos[0] << "," << tail_pos[1] << "\n";
    }
    for (int i=0; i<abs(dy); i++){
        head_pos[1] += sgn(dy);
        if(!are_nearby(head_pos, tail_pos)) {
            tail_pos[1]+=sgn(dy);
            tail_pos[0] += sgn(head_pos[0]-tail_pos[0]);
        }
        vis.insert(stringify(tail_pos));
        //std::cout << "HEAD: " << head_pos[0] << "," << head_pos[1] << "\n";
        //std::cout << "TAIL: " << tail_pos[0] << "," << tail_pos[1] << "\n";
    }
    //std::cout << "DONE\n";
    return tail_pos;
}


int main()  {
    std::ifstream input_file;
    input_file.open("input9");
    std::string instruction;
    std::vector<int> head {0,0};
    std::vector<int> tail {0,0};
    std::unordered_set<std::string> visited {"0-0"};

    while(getline(input_file, instruction)) {
        char direction = instruction[0];
        int length = std::stoi(instruction.substr(2));
        const auto [dx, dy] = get_direction(direction);
        tail = update_tail(tail, head, length * dx, length * dy, visited);
        visited.insert(stringify(tail));
        head[0] += length * dx;
        head[1] += length * dy;
        //std::cout << "Head:" << head[0] << ", " << head[1] << "\n";
        //std::cout << "Tail:" << tail[0] << ", " << tail[1] << "\n";
    }
  std::cout << visited.size();
}
#+end_src

#+RESULTS:

#+begin_src cpp :results output :main no :includes <chrono> <iostream> <fstream> <string> <vector> <unordered_set> :options -Wall -Wextra :tangle yes

const std::pair<int,int> get_direction(const char dir) {
    if (dir == 'U') return std::pair(0,1);
    else if (dir == 'D') return std::pair(0,-1);
    else if (dir == 'L') return std::pair(-1,0);
    else if (dir == 'R') return std::pair(1,0);
    else return std::pair(0,0);
}


bool are_nearby(const std::vector<int> head, const std::vector<int> tail) {
    return abs(head[0] - tail[0]) <= 1 && abs(head[1] - tail[1]) <= 1;
}

template <typename T> int sgn(T val) {
    return (T(0) < val) - (val < T(0));
}

long longify(const std::vector<int>& p){
    return static_cast<long>(p[0]) + static_cast<long>(p[1]) << 32;
};
const std::vector<std::vector<int>> update_tail(std::vector<std::vector<int>> tails, const int dx, const int dy, std::unordered_set<long>& vis) {

     for (int i=0; i<abs(dx); i++){
            tails[0][0]+=sgn(dx);
            for (size_t j=1; j<tails.size(); j++){
                if(!are_nearby(tails[j-1], tails[j])) {
                    tails[j][0] += sgn(tails[j-1][0]-tails[j][0]);
                    tails[j][1] += sgn(tails[j-1][1]-tails[j][1]);

                }
                if(j==tails.size()-1)
                    vis.insert(longify(tails[j]));
            }
        }
     for (int i=0; i<abs(dy); i++){
            tails[0][1]+=sgn(dy);
            for (size_t j=1; j<tails.size(); j++){
                if(!are_nearby(tails[j-1], tails[j])) {
                    tails[j][1] += sgn(tails[j-1][1]-tails[j][1]);
                    tails[j][0] += sgn(tails[j-1][0]-tails[j][0]);

                }
                if(j==tails.size()-1)
                    vis.insert(longify(tails[j]));
            }
        }
            return tails;
        }


             int main()  {
                 using std::chrono::high_resolution_clock;
                 using std::chrono::duration_cast;
                 using std::chrono::duration;

                 std::ifstream input_file;
                 input_file.open("input9");

                 auto ms_int = 0;
                 std::string instruction;

                 std::vector<std::vector<int>> tails(10, std::vector<int>(2));
                 std::vector<std::vector<int>> newtails(10, std::vector<int>(2));
                 std::unordered_set<long> visited {0};

                 while(getline(input_file, instruction)) {
                     auto t1 = high_resolution_clock::now();
                     char direction = instruction[0];
                     int length = std::stoi(instruction.substr(2));
                     const auto [dx, dy] = get_direction(direction);
                     tails  = update_tail(tails, length * dx, length * dy, visited);
                     auto t2 = high_resolution_clock::now();
                     ms_int += duration_cast<std::chrono::microseconds>(t2 - t1).count();
                 }
                 std::cout << visited.size() << "\n";
                 std::cout << ms_int << "\n";
             }
#+end_src

#+RESULTS:
: 354
: 49792

** Day 10
#+begin_src elixir :exports both
defmodule CRT do
  def init do
    Task.start_link(fn -> loop(0,"") end)
  end
  defp loop(insc,screen) do
    receive do
      {:print} -> IO.puts(screen); loop(insc,screen)
      {pos} ->
        screen1 =
        if rem(insc, 40) == 0 do
          screen <> "\n"
        else
          screen
        end
        if abs(rem(insc,40) - pos) <= 1 do
          screen2 = screen1 <> "#"
          loop(insc+1,screen2)
        else
          screen2 = screen1 <> "."
          loop(insc+1,screen2)
        end
    end
  end
end
defmodule CPU do
  def init(crt) do
    Task.start_link(fn -> loop(0,1,[],true,crt) end)
  end
  defp loop(insc, state, callbacks,receptive,crt) do
    state1 = List.foldr(callbacks, state, fn {n, func}, state -> if insc == n do func.(state) else state end end)

    if receptive do
      receive do
        {:noop} ->  send crt, {state1}; loop(insc+1, state1, callbacks,true, crt)
        {:addx, n} ->   send crt, {state1}; loop(insc+1, state1, [{insc+2, fn state -> state + n end} | callbacks], false, crt)
        {:get, caller} ->
            send caller, {insc, state1}
            loop(insc, state, callbacks, true, crt)
      end
    else
      send crt, {state1}
      loop(insc+1,state1,callbacks,true, crt)
    end
  end
end
instrs = Enum.map(String.split(File.read!("input10"),"\n"), fn x -> String.split(x, " ") end)
{:ok, crt} = CRT.init
{:ok, cpu} = CPU.init(crt)

for {instr, _idx} <- Enum.with_index(instrs) do
    case instr do
      ["noop"] -> send cpu, {:noop}

      ["addx", nstr] ->
          {n, _} = Integer.parse(nstr)
          send cpu, {:addx, n}
      [""] -> {}
    end

      send cpu, {:get, self()}
      receive do
        {insc, state} ->
          if rem(insc - 20, 40) == 38 or rem(insc - 20, 40) == 39 or insc == 19 do
            IO.write(state); IO.write(", "); IO.puts(insc)
          end
      end

end
send crt,{:print}
#+end_src

#+RESULTS:
#+begin_example

21, 19
21, 59
17, 98
21, 138
21, 179
21, 219

####.####.###..###..###..####.####.####.
#.......#.#..#.#..#.#..#.#.......#.#.... 
###....#..###..#..#.###..###....#..###..
#.....#...#..#.###..#..#.#.....#...#.... 
#....#....#..#.#....#..#.#....#....#....
#....####.###..#....###..#....####.#.... 
#+end_example

#+begin_src calc :exports both
    21*20+21*60+17*100+21*140+21*180+21*220
#+end_src

#+RESULTS:
: 14720

** Day 11
#+begin_src crystal :results output :exports both
def eval_expression(operator : String, left : String, right : String, i : Int32)
  l = left == "old" ? i : left.to_i
  r = right == "old" ? i : right.to_i
  if operator == "*"
    return l * r
  else
    return l + r
  end
end

class Monkey
  property items : Array(Int32)
  property expr : Int32 -> Int32
  property divider : Int32 -> Bool
  property iftrue : Int32
  property iffalse : Int32
  property inspection_count : Int32
  def initialize(@items, @expr, @divider, @iftrue, @iffalse)
    @inspection_count = 0
  end
end

def parse_expression(str : String) : Int32 -> Int32
  strs = str.split
  operator = strs[1]
  left = strs[0]
  right = strs[2]
  return ->(x : Int32) { eval_expression(operator, left, right, x) }
end

def process_entry(str : Array(String)) : Monkey
  number = str[0][7..-2].to_i
  starting_items = str[1][18..].split(", ").map {|a| a.to_i}
  expression_raw = str[2][19..]
  divider = str[3][21..].to_i
  iftrue_monkey = str[4][29..].to_i
  iffalse_monkey = str[5][29..].to_i
  return Monkey.new(
          starting_items,
          parse_expression(expression_raw),
          ->(x : Int32) { x.divisible_by?(divider) },
          iftrue_monkey,
          iffalse_monkey)
end


input = File.read("input11").split("\n\n").map {|a| a.split("\n")}
entries = input.map { |e| process_entry(e) }
20.times {|i|
entries.map_with_index { |monkey, idx|
  items = monkey.items
  items.each { |level|
    monkey.inspection_count += 1
    level = monkey.expr.call(level)
    level = level // 3
    if monkey.divider.call(level)
      entries[monkey.iftrue].items = entries[monkey.iftrue].items << level
    else
      entries[monkey.iffalse].items = entries[monkey.iffalse].items << level
    end
  }
  monkey.items = [] of Int32
  }

}
puts((entries.map {|monkey| monkey.inspection_count}).sort[-2..].reduce {|a,b| a * b})
#+end_src

#+RESULTS:
: 113232


For part 2, we have to consider that all of these test criteria consist of divisibility
by prime numbers \(p_i\), which is not affected by treating everything in $\mathbb{Z}/\prod_{i} p_{i}\mathbb{Z}$.

#+begin_src crystal :results output :exports both :tangle yes :options --release
require "benchmark"
def eval_expression(operator : String, left : String, right : String, i : Int64)
  l = left == "old" ? i : left.to_i64
  r = right == "old" ? i : right.to_i64
  if operator == "*"
    return l * r
  else
    return l + r
  end
end

class Monkey
  property items : Array(Int64)
  property expr : Int64 -> Int64
  property divider : Int64
  property iftrue : Int64
  property iffalse : Int64
  property inspection_count : Int64
  def initialize(@items, @expr, @divider, @iftrue, @iffalse)
    @inspection_count = 0
  end
end

def parse_expression(str : String) : Int64 -> Int64
  strs = str.split
  operator = strs[1] == "*" ? ->(x : Int64, y : Int64) {x * y} :\
    ->(x : Int64, y : Int64) {x + y}
  left = strs[0] == "old" ? (-1).to_i64 : strs[0].to_i64
  right = strs[2] == "old" ? (-1).to_i64 : strs[2].to_i64
  return ->(i : Int64)
  { l = left == -1 ? i : left
    r = right == -1 ? i : right
    operator.call(l,r) }
end

def process_entry(str : Array(String)) : Monkey
  number = str[0][7..-2].to_i
  starting_items = str[1][18..].split(", ").map {|a| a.to_i64}
  expression_raw = str[2][19..]
  divider = str[3][21..].to_i64
  iftrue_monkey = str[4][29..].to_i64
  iffalse_monkey = str[5][29..].to_i64
  return Monkey.new(
          starting_items,
          parse_expression(expression_raw),
          divider,
          iftrue_monkey,
          iffalse_monkey)
end


input = File.read("input11").split("\n\n").map {|a| a.split("\n")}
entries = input.map { |e| process_entry(e) }
prime_product = entries.reduce(1) { |acc, e| e.divider * acc }
puts Benchmark.measure {10000.times {|i|
entries.each { |monkey|
  monkey.items.each { |level|
    monkey.inspection_count += 1
    level = monkey.expr.call(level)
    level = level % prime_product
    idx = level.divisible_by?(monkey.divider) ? monkey.iftrue : monkey.iffalse
    entries[idx].items = entries[idx].items << level
  }
  monkey.items = [] of Int64
  }

}
}
puts((entries.map {|monkey| monkey.inspection_count}).sort[-2..].reduce {|a,b| a * b})
#+end_src

#+RESULTS:
:   0.126909   0.000296   0.127205 (  0.127220)
: 29703395016

** Day 12
#+begin_src nim :exports both
import astar, hashes, sequtils
type Grid = seq[seq[int]]
type Point = tuple[x,y : int]
template yieldIfExists( grid: Grid, height : int, point: Point ) =
    ## Checks if a point exists within a grid, then calls yield it if it does
    let exists =
        point.y >= 0 and point.y < grid.len and
        point.x >= 0 and point.x < grid[point.y].len
    if exists and grid[point.y][point.x] <= height + 1:
        yield point
iterator neighbors*( grid: Grid, point: Point ): Point =
    ## An iterator that yields the neighbors of a given point
    yieldIfExists( grid, grid[point.y][point.x], (x: point.x - 1, y: point.y) )
    yieldIfExists( grid, grid[point.y][point.x], (x: point.x + 1, y: point.y) )
    yieldIfExists( grid, grid[point.y][point.x], (x: point.x, y: point.y - 1) )
    yieldIfExists( grid, grid[point.y][point.x], (x: point.x, y: point.y + 1) )

proc cost*(grid: Grid, a, b: Point): float =
    ## Returns the cost of moving from point `a` to point `b`
    float(1)
    #float((b.x-a.x) + (b.y-a.y))

proc heuristic*( grid: Grid, node, goal: Point ): float =
    ## Returns the priority of inspecting the given node
    asTheCrowFlies[Point](node, goal) - cast[float](grid[node.y][node.x])

proc find_char(input : seq[seq[char]], ch : char) : tuple[x,y:int] =
  for iy, y in input:
    for ix, x in y:
      if x == ch:
        return (ix,iy)

proc get_height(ch: char) : int =
  if ch == 'S': 0
  elif ch == 'E': 25
  else: ord(ch) - ord('a')


let strings = readLines("input12", 41)
let seqs = map(strings, proc(x:string):seq[char] = cast[seq[char]](x))
let start = find_char(seqs, 'S')
let goal = find_char(seqs, 'E')
let grid = map[seq[char],seq[int]](seqs, (proc(x:seq[char]):seq[int] = map(x, get_height)))
var dists : seq[int] = @[]
for iy in 0 .. len(strings) - 1:
  for ix in 0 .. len(strings[0]) - 1:
    if grid[iy][ix] == 0:
      let ps = toSeq(path[Grid, Point, float](grid,(ix,iy),goal))
      if len(ps) > 0:
        dists = dists & (len(ps)-1)

echo min(dists)
    
var i = 0
let ps = toSeq(path[Grid, Point, float](grid,start,goal))
for iy in 0 .. len(strings) - 1:
  for ix in 0 .. len(strings[0]) - 1:
    if (ix,iy) in ps:
      stdout.write strings[iy][ix]
    else:
      stdout.write '.'
  echo ""
#for point in path[Grid, Point, float](grid, start, goal):
#    echo point
#    i += 1
#echo (i-1)
echo len(ps)
#+end_src

#+RESULTS:
| 332                                                                |
| .................................................................. |
| .................................................................. |
| .................................................................. |
| .................................................................. |
| .................................................................. |
| .................................................................. |
| .................................................................. |
| .................................................................. |
| ...............................................jjjk............... |
| ............................................jjjj..kkk............. |
| ...................................iiiiiijjjj.......k............. |
| ..................................ii..........rrrp..kk............ |
| ..................................i...qqqrrrrrr..pp..k............ |
| .................................ii.qqq...........pp.k............ |
| .................................h..q........uuuu..p.k............ |
| .................................h..q..tttuuuu..uu.p.k............ |
| .................................h..q..t.........u.p.ll........... |
| .................................h..q..t.........u.p..ll.......... |
| .................................h..q..t.........v.pp..ll......... |
| .................................h..p..t.........vv.pq..l......... |
| Sb...............................h..p..t...E......vv.qq.ll........ |
| .b..............................hh.pp.ss.xxy.......v..q..l........ |
| .b..............................g..p.ss.xy........vv..q..l........ |
| .b..............................g.pp.s..wwww...vvvv..qq.ll........ |
| .b....................cccccccc.gg.p..s.....w...w....qq..m......... |
| .b....................c......c.g..p..sss...ww..w.qqqq..mm......... |
| .bccccccc...........ccc......c.gg.pp...ssss.wwww.r..mmmm.......... |
| ........ccccccccccccc........c..g..ooo....sr....rr.mm............. |
| .............................c..gg...ooooo.rr...r.nm.............. |
| .............................cc..gg......oo.rrrrr.n............... |
| ..............................cc..fffff...oo.....nn............... |
| ...............................cc.....fff..n.....n................ |
| ................................cccc....ff.nnnnnnn................ |
| ...................................cccc..fe....................... |
| ......................................cc..ee...................... |
| .......................................c...eeeeeeeed.............. |
| .......................................c...........c.............. |
| .......................................c.........ccc.............. |
| .......................................cc........c................ |
| ........................................cccccccc.c................ |
| ...............................................ccc................ |
| 340                                                                |

**

* Potential languages
** D
- https://dlang.org
- static
- funky templates and contracts
- great org support

** Forth
- very hard to get used to imo
- would be interesting though

** Java
- about as basic as it gets
- annoying stdlib though

** OCaml
- potentially interesting
- can't be too hard from a functional POV
- stdlib seems a little lacking though

** Perl
- why

** C#
- essentially just better Java
- is considered fairly fun to write
- maybe a little overhead-heavy for AOC

** Io
- https://iolanguage.org/index.html
- smalltalk for millenials
- message driven stuff is cool so this looks interesting

** R
- probably too statistics-heavy

** Nim
- https://nim-lang.org/
- statically typed python
- the crystal of snakes???

** Rust
- it's rust
- can't hurt though it might take forever to get into it

** Typescript
- a couple people think it's decent
- the nim of js???

** Zig
- super deranged compile time shit
- bit too much overhead maybe?
