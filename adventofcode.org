* Advent of Code 2022

** Day 1
#+begin_src python :exports both
inp = open("/home/uni/Sync/aoc/input1").readlines()
splits = []
s = []
for i in inp:
  if i == "\n":
    splits.append(s.copy())
    s = []
  else:
    s.append(int(i.strip()))
splits = map(sum, splits)
return sum(sorted(splits)[-3:])
#+END_src

#+RESULTS:
: 198041

** Day 2
#+begin_src haskell :compile yes :results output :exports both
import Data.Char
main =  print . func . (map (\[[x],[y]] -> (x,y))) . map words . lines =<< readFile "/home/uni/Sync/aoc/input2"
func :: [(Char, Char)] -> Int
func = sum . map (\(a,b) -> charScore a b + winScore a b)
  where charScore a b =
          (ord b - ord 'X' + 1)
        winScore a b | (ord a - ord 'A') == (ord b - ord 'X') = 3
                     | otherwise = case (a,b) of
                         ('A','Y') -> 6
                         ('B','Z') -> 6
                         ('C','X') -> 6
                         _         -> 0
#+end_src

#+RESULTS:
: 11666

#+begin_src haskell :compile yes :results output :exports both
import Data.Char
main =  print . func . (map (\[[x],[y]] -> (x,y))) . map words . lines =<< readFile "/home/uni/Sync/aoc/input2"
func :: [(Char, Char)] -> Int
func = sum . map (\(a,b) -> charScore a b + winScore a b) . map (\(x,y) -> (x,choosePlay x y))
  where charScore a b =
          (ord b - ord 'X' + 1)
        winScore a b | (ord a - ord 'A') == (ord b - ord 'X') = 3
                     | otherwise = case (a,b) of
                         ('A','Y') -> 6
                         ('B','Z') -> 6
                         ('C','X') -> 6
                         _         -> 0
        choosePlay a 'Y' = chr ((ord a - ord 'A') + ord 'X')
        choosePlay 'A' 'X' = 'Z'
        choosePlay 'B' 'X' = 'X'
        choosePlay 'C' 'X' = 'Y'
        choosePlay 'A' 'Z' = 'Y'
        choosePlay 'B' 'Z' = 'Z'
        choosePlay 'C' 'Z' = 'X'
#+end_src

#+RESULTS:
: 12767

** Day 3
#+begin_src ruby :results output :exports both
class String
  def halves
    chars.each_slice(size / 2).map(&:join)
  end
    end
n = 0
File.foreach("input3") do |x|
  dep1, dep2 = x.halves
  char = (dep1.split('') & dep2.split('')).first
  n += (char.bytes.map {|x| x - 64}.first)+26  if char == char.upcase
  n += (char.bytes.map {|x| x - 96}.first)  if char == char.downcase
end
puts n
     n = 0
File.foreach("input3").each_slice(3) do |xs|
  char = (xs[0].split('') & xs[1].split('') & xs[2].split('')).first
  n += (char.bytes.map {|x| x - 64}.first)+26  if char == char.upcase
  n += (char.bytes.map {|x| x - 96}.first)  if char == char.downcase
end
puts n
#+end_src

#+RESULTS:
: 7848
: 2616

** Day 4
#+begin_src bash :exports both
i=0;
while read p; do
p=(${p//[,-]/ })
if (( (p[0] <= p[2] && p[1] >= p[3]) || (p[0] >= p[2] && p[1] <= p[3]) ))
then
$((i+=1))
fi
done < input4
echo $i
#+end_src

#+RESULTS:
: 500

#+begin_src bash :exports both
i=0;
while read p; do
p=(${p//[,-]/ })
if (( (p[0] <= p[2] && p[1] >= p[2]) || (p[0] >= p[2] && p[0] <= p[3]) ))
then
$((i+=1))
fi
done < input4
echo $i
#+end_src

#+RESULTS:
: 815

** Day 5
#+begin_src racket :results output :exports both
#lang racket

(define (string-group input n)
   (map (lambda (x) (substring input x (min (+ x n) (string-length input)))) (range 0 (string-length input) n)))
(define (parse input)
  (let* ((split1 (string-split input "\n\n"))
         (header* (first split1))
         (header**
          (apply map list
                 (map (lambda (a)
                       (string-group a 4)) (string-split  header* "\n"))))
         (header (map (lambda (a) (filter non-empty-string? (map (lambda (b) (string-trim (string-replace b #rx"\\[|\\]*" ""))) (drop-right a 1)))) header**))
         (footer* (map (lambda (a) (list (string->number (second (string-split a))) (string->number (fourth (string-split a))) (string->number (sixth (string-split a))))) (string-split (second split1) "\n")))) (list header footer*)))



(define (act-single value many from to)
  (list-update (list-update value (- to 1)
                            (lambda (u)
                              (append
                               (reverse
                                (take (list-ref value (- from 1)) many))
                               u)))
    (- from 1)
    (lambda (u) (drop u many))))


(define (act-single* value many from to)
  (list-update (list-update value (- to 1)
                            (lambda (u)
                              (append
                                (take (list-ref value (- from 1)) many)
                               u)))
    (- from 1)
    (lambda (u) (drop u many))))



(define (act header footer) (foldl (lambda (a b) (act-single b (first a) (second a) (third a))) header footer))
(define (act* header footer) (foldl (lambda (a b) (act-single* b (first a) (second a) (third a))) header footer))
(define part1 (apply string-append (map first (apply act (parse (file->string "input5"))))))
(define part2 (apply string-append (map first (apply act* (parse (file->string "input5"))))))
part1
part2

#+end_src

#+RESULTS:
: "WHTLRMZRC"
: "GMPMLWNMG"


** Day 6
#+begin_src C :includes <stdio.h> :exports both
    FILE* file = fopen("input6","r");
    int i = 0;
    char* chars = malloc(4);
    for(;;){
      fseek(file, i, SEEK_SET);
      chars[0] = fgetc(file);
      chars[1] = fgetc(file);
      chars[2] = fgetc(file);
      chars[3] = fgetc(file);
      if(chars[0] != chars[1] && chars[0] != chars[2] && chars[0] != chars[3] && chars[1] != chars[2] && chars[1] != chars[3] && chars[2] != chars[3]) {
        printf("%d", i + 4);
        return 0;
      }
      if(chars[0] == 0) return 0;
      i++;

    }

#+end_src

#+RESULTS:
: 1658


#+begin_src C :includes <stdio.h> :exports both
    FILE* file = fopen("input6","r");
    int i = 0;
    char* chars = malloc(14);
    for(;;){
      fseek(file, i, SEEK_SET);
      int alldifferent = 1;
      for(int j = 0; j < 14; j++) {
        chars[j] = fgetc(file);
        for(int k = 0; k < j; k++) {
          if(chars[k] == chars[j]) alldifferent = 0;
        }
      }
      if(alldifferent){
        printf("%d", i + 14);
        return 0;
      }
      if(chars[0] == 0) return 0;
      i++;

    }

#+end_src

#+RESULTS:
: 2260

** Day 7

#+begin_src js :results output :exports both
const fs = require('fs');
const input = fs.readFileSync('input7', 'utf8').split("\n").slice(1).map(element => { return element.trim().split(" "); });

function accessJSON(d,p) {
    d2 = d;
    for(i of p) {
        d2 = d2[p];
    }
    return d2;
}

path = [];
data = {'/': 0};
lsMode = false;
for(const line of  input) {
    if(line[0] == "$") {
        if(line[1] == "ls") {

        }
        else if(line[1] == "cd") {

            if(line[2] == "..") { path = path.slice(0,path.length-1);  }
            else {
                //console.log(("data".concat("[\"",path.join("\"][\""), "\"\]", "= {};")));
                data["/"+path.join("/")] = isNaN(data["/"+path.join("/")]) ? 0 : data["/"+path.join("/")];
                path.push(line[2]);
                data["/"+path.join("/")] = isNaN(data["/"+path.join("/")]) ? 0 : data["/"+path.join("/")];
            }
        }
    }
    else if("dir" != line[0]) {
        size = +line[0];
        file = line[1];
        //console.log(path, data["/"+path.slice(0,i).join("/")], +line[0]);
        for(var i = 0; i <= path.length; i++) {
            //console.log("/"+path.slice(0,i).join("/"));
            data["/"+path.slice(0,i).join("/")] += size;
        }
    }
}


console.log(Object.values(data).filter(element => {return element < 100000; }).reduce((a,b) => a + b,0));
free = 70000000 - data["/"];
needed = 30000000 - free;

var filtered = Object.keys(data ).reduce(function (filtered, key) {
    if (data[key] >= needed) filtered[key] = data[key];
    return filtered;
}, {});

var [lowestItems] = Object.entries(filtered).sort(([ ,v1], [ ,v2]) => v1 - v2);
console.log(lowestItems);
#+end_src

#+RESULTS:
: 1444896
: [ '/jvwtm/zjmldjdh/mdclfbs', 404395 ]

** Day 8
#+begin_src octave :exports both
siz = 99;
file = fopen("input8");
a = zeros(siz);
seen = zeros(siz);
for i = 1:siz;
  for j=1:siz;
    a(i,j) = str2double(fgets(file,1));
  end
  fgets(file,1);
end
for i = 1:siz;
  oldLeft = -1;
  for j=1:siz;
    if(a(i,j) < oldLeft);
      %break
    else
      if(a(i,j) > oldLeft);
        seen(i,j) = 1;
      end
      oldLeft = a(i,j);
    end
  end
end
for i = 1:siz;
  oldRight = -1;
  for j=1:siz;
    if(a(i,siz+1-j) < oldRight);
      %break
    else
      if(a(i,siz+1-j) > oldRight);
        seen(i,siz+1-j) = 1;
      end
      oldRight = a(i,siz+1-j);
    end
  end
end
for j = 1:siz;
  oldTop = -1;
  for i=1:siz;
    if(a(i,j) < oldTop);
      %break
    else
      if(a(i,j) > oldTop);
        seen(i,j) = 1;
      end
      oldTop = a(i,j);
    end
  end
end
for j = 1:siz;
  oldBottom = -1;
  for i=1:siz;
    if(a(siz+1-i,j) < oldBottom);
      %break
    else
      if(a(siz+1-i,j) > oldBottom);
        seen(siz+1-i,j) = 1;
      end
      oldBottom = a(siz+1-i,j);
    end
  end
end
sum(seen(:))
#+end_src

#+RESULTS:
: 1719

#+begin_src octave :exports both
siz = 99;
file = fopen("input8");
a = zeros(siz);
score = zeros(siz);
for i = 1:siz;
  for j=1:siz;
    a(i,j) = str2double(fgets(file,1));
  end
  fgets(file,1);
end
for i=1:siz;
  for j=1:siz;
    down=0;
    for d=i+1:siz;
      down = down + 1;
      if(a(d,j) >= a(i,j));
        break
      end
    end
    up=0;
    for d=i-1:-1:1;
      up = up + 1;
      if(a(d,j) >= a(i,j));
        break
      end
    end
    right=0;
    for d=j+1:siz;
      right = right + 1;
      if(a(i,d) >= a(i,j));
        break
      end
    end
    left=0;
    for d=j-1:-1:1;
      left = left + 1;
      if(a(i,d) >= a(i,j));
        break
      end
    end
    score(i,j) = down * up * left * right;
  end
end
max(score(:))
#+end_src

#+RESULTS:
: 590824
